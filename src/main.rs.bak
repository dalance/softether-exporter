
#[macro_use]
extern crate prometheus;
extern crate hyper;
extern crate csv;
extern crate toml;
#[macro_use]
extern crate lazy_static;
#[macro_use]
extern crate serde_derive;

use hyper::header::ContentType;
use hyper::server::{Server, Request, Response};
use hyper::mime::Mime;
use prometheus::{GaugeVec,Encoder,TextEncoder};
use std::process;
use std::process::Command;
use std::error::Error;
use std::env;
use std::fs::File;
use std::io::Read;

lazy_static! {
    static ref ONLINE: GaugeVec = register_gauge_vec!(
        "softether_online",
        "test",
        &["hub"]
    ).unwrap();

    static ref SESSIONS: GaugeVec = register_gauge_vec!(
        "softether_sessions",
        "test",
        &["hub"]
    ).unwrap();

    static ref SESSIONS_CLIENT: GaugeVec = register_gauge_vec!(
        "softether_sessions_client",
        "test",
        &["hub"]
    ).unwrap();

    static ref SESSIONS_BRIDGE: GaugeVec = register_gauge_vec!(
        "softether_sessions_bridge",
        "test",
        &["hub"]
    ).unwrap();

    static ref USERS: GaugeVec = register_gauge_vec!(
        "softether_users",
        "test",
        &["hub"]
    ).unwrap();

    static ref GROUPS: GaugeVec = register_gauge_vec!(
        "softether_groups",
        "test",
        &["hub"]
    ).unwrap();

    static ref MAC_TABLES: GaugeVec = register_gauge_vec!(
        "softether_mac_tables",
        "test",
        &["hub"]
    ).unwrap();

    static ref IP_TABLES: GaugeVec = register_gauge_vec!(
        "softether_ip_tables",
        "test",
        &["hub"]
    ).unwrap();

    static ref LOGINS: GaugeVec = register_gauge_vec!(
        "softether_logins",
        "test",
        &["hub"]
    ).unwrap();

    static ref OUTGOING_UNICAST_PACKETS: GaugeVec = register_gauge_vec!(
        "softether_outgoing_unicast_packets",
        "test",
        &["hub"]
    ).unwrap();

    static ref OUTGOING_UNICAST_BYTES: GaugeVec = register_gauge_vec!(
        "softether_outgoing_unicast_bytes",
        "test",
        &["hub"]
    ).unwrap();

    static ref OUTGOING_BROADCAST_PACKETS: GaugeVec = register_gauge_vec!(
        "softether_outgoing_broadcast_packets",
        "test",
        &["hub"]
    ).unwrap();

    static ref OUTGOING_BROADCAST_BYTES: GaugeVec = register_gauge_vec!(
        "softether_outgoing_broadcast_bytes",
        "test",
        &["hub"]
    ).unwrap();

    static ref INCOMING_UNICAST_PACKETS: GaugeVec = register_gauge_vec!(
        "softether_incoming_unicast_packets",
        "test",
        &["hub"]
    ).unwrap();

    static ref INCOMING_UNICAST_BYTES: GaugeVec = register_gauge_vec!(
        "softether_incoming_unicast_bytes",
        "test",
        &["hub"]
    ).unwrap();

    static ref INCOMING_BROADCAST_PACKETS: GaugeVec = register_gauge_vec!(
        "softether_incoming_broadcast_packets",
        "test",
        &["hub"]
    ).unwrap();

    static ref INCOMING_BROADCAST_BYTES: GaugeVec = register_gauge_vec!(
        "softether_incoming_broadcast_bytes",
        "test",
        &["hub"]
    ).unwrap();

}

#[derive(Debug, Deserialize)]
struct Config {
    listen_port: Option<u32>,
    vpncmd     : Option<String>,
    server     : Option<String>,
    hubs       : Vec<Hub>,
}

#[derive(Debug, Deserialize, Clone)]
struct Hub {
    name    : Option<String>,
    password: Option<String>,
}

impl Config {
    fn from_file( file: &str ) -> Result<Config, Box<Error>> {
        let mut f = File::open( file )?;
        let mut s = String::new();
        let _ = f.read_to_string( &mut s );
        let config: Config = toml::from_str( &s )?;
        Ok( config )
    }
}

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() < 2 {
        return
    }

    let config = match Config::from_file( &args[1] ) {
        Ok ( x ) => x,
        Err( x ) => { println!( "Config ( {} ) read failed: {}", &args[1], x ); process::exit( 1 ) },
    };

    let encoder = TextEncoder::new();
    let addr    = format!( "0.0.0.0:{}", config.listen_port.unwrap_or( 9999 ) );
    let vpncmd  = config.vpncmd.unwrap_or( String::from( "vpncmd" ) );
    let server  = config.server.unwrap_or( String::from( "localhost" ) );
    let hubs    = config.hubs;

    println!( "Server started: {}", addr );

    Server::http( addr )
        .unwrap()
        .handle( move |_: Request, mut res: Response| {

            for hub in hubs.clone() {
                let name     = hub.name.unwrap_or( String::from( "" ) );
                let password = hub.password.unwrap_or( String::from( "" ) );
                let reader   = SoftEtherReader::new( &vpncmd, &server );
                let status   = match reader.hub_status( &name, &password ) {
                    Ok ( x ) => x,
                    Err( x ) => { println!( "Hub status read failed: {}", x ); process::exit( 1 ) },
                };


                ONLINE                    .with_label_values(&[&status.name]).set( if status.online { 1.0 } else { 0.0 } );
                SESSIONS                  .with_label_values(&[&status.name]).set( status.sessions );
                SESSIONS_CLIENT           .with_label_values(&[&status.name]).set( status.sessions_client );
                SESSIONS_BRIDGE           .with_label_values(&[&status.name]).set( status.sessions_bridge );
                USERS                     .with_label_values(&[&status.name]).set( status.users );
                GROUPS                    .with_label_values(&[&status.name]).set( status.groups );
                MAC_TABLES                .with_label_values(&[&status.name]).set( status.mac_tables );
                IP_TABLES                 .with_label_values(&[&status.name]).set( status.ip_tables );
                LOGINS                    .with_label_values(&[&status.name]).set( status.logins );
                OUTGOING_UNICAST_PACKETS  .with_label_values(&[&status.name]).set( status.outgoing_unicast_packets );
                OUTGOING_UNICAST_BYTES    .with_label_values(&[&status.name]).set( status.outgoing_unicast_bytes );
                OUTGOING_BROADCAST_PACKETS.with_label_values(&[&status.name]).set( status.outgoing_broadcast_packets );
                OUTGOING_BROADCAST_BYTES  .with_label_values(&[&status.name]).set( status.outgoing_broadcast_bytes );
                INCOMING_UNICAST_PACKETS  .with_label_values(&[&status.name]).set( status.incoming_unicast_packets );
                INCOMING_UNICAST_BYTES    .with_label_values(&[&status.name]).set( status.incoming_unicast_bytes );
                INCOMING_BROADCAST_PACKETS.with_label_values(&[&status.name]).set( status.incoming_broadcast_packets );
                INCOMING_BROADCAST_BYTES  .with_label_values(&[&status.name]).set( status.incoming_broadcast_bytes );
            }

            let metric_familys = prometheus::gather();
            let mut buffer = vec![];
            encoder.encode( &metric_familys, &mut buffer ).unwrap();
            res.headers_mut().set( ContentType( encoder.format_type().parse::<Mime>().unwrap()));
            res.send( &buffer ).unwrap();
        })
        .unwrap();
}

struct SoftEtherReader {
    pub vpncmd: String,
    pub server: String,
}

impl SoftEtherReader {
    pub fn new( vpncmd: &str, server: &str ) -> SoftEtherReader {
        SoftEtherReader {
            vpncmd: String::from( vpncmd ),
            server: String::from( server ),
        }
    }

    pub fn hub_status( self, hub: &str, password: &str ) -> Result<HubStatus, Box<Error>> {
        let output = Command::new( self.vpncmd )
            .arg( self.server )
            .arg( "/SERVER" )
            .arg( format!( "/HUB:{}", hub ) )
            .arg( format!( "/PASSWORD:{}", password ) )
            .arg( "/CSV" )
            .arg( "/CMD" )
            .arg( "StatusGet" )
            .output()?;

        let mut rdr = csv::Reader::from_reader( output.stdout.as_slice() );
        let mut status = HubStatus::new();

        for entry in rdr.records() {
            let entry = entry?;
            let key = entry.get( 0 ).unwrap_or( "" );
            let val = entry.get( 1 ).unwrap_or( "" );
            match key.as_ref() {
                "仮想 HUB 名"                     => status.name                       = String::from( val ),
                "状態"                            => status.online                     = if val == "オンライン" { true } else { false },
                "セッション数"                    => status.sessions                   = val.parse()?,
                "セッション数 (クライアント)"     => status.sessions_client            = val.parse()?,
                "セッション数 (ブリッジ)"         => status.sessions_bridge            = val.parse()?,
                "ユーザー数"                      => status.users                      = val.parse()?,
                "グループ数"                      => status.groups                     = val.parse()?,
                "MAC テーブル数"                  => status.mac_tables                 = val.parse()?,
                "IP テーブル数"                   => status.ip_tables                  = val.parse()?,
                "ログイン回数"                    => status.logins                     = val.parse()?,
                "送信ユニキャストパケット数"      => status.outgoing_unicast_packets   = SoftEtherReader::decode_packets( val )?,
                "送信ユニキャスト合計サイズ"      => status.outgoing_unicast_bytes     = SoftEtherReader::decode_bytes( val )?,
                "送信ブロードキャストパケット数"  => status.outgoing_broadcast_packets = SoftEtherReader::decode_packets( val )?,
                "送信ブロードキャスト合計サイズ"  => status.outgoing_broadcast_bytes   = SoftEtherReader::decode_bytes( val )?,
                "受信ユニキャストパケット数"      => status.incoming_unicast_packets   = SoftEtherReader::decode_packets( val )?,
                "受信ユニキャスト合計サイズ"      => status.incoming_unicast_bytes     = SoftEtherReader::decode_bytes( val )?,
                "受信ブロードキャストパケット数"  => status.incoming_broadcast_packets = SoftEtherReader::decode_packets( val )?,
                "受信ブロードキャスト合計サイズ"  => status.incoming_broadcast_bytes   = SoftEtherReader::decode_bytes( val )?,
                "Virtual Hub Name"                => status.name                       = String::from( val ),
                "Status"                          => status.online                     = if val == "Online" { true } else { false },
                "Sessions"                        => status.sessions                   = val.parse()?,
                "Sessions (Client)"               => status.sessions_client            = val.parse()?,
                "Sessions (Bridge)"               => status.sessions_bridge            = val.parse()?,
                "Users"                           => status.users                      = val.parse()?,
                "Groups"                          => status.groups                     = val.parse()?,
                "MAC Tables"                      => status.mac_tables                 = val.parse()?,
                "IP Tables"                       => status.ip_tables                  = val.parse()?,
                "Num Logins"                      => status.logins                     = val.parse()?,
                "Outgoing Unicast Packets"        => status.outgoing_unicast_packets   = SoftEtherReader::decode_packets( val )?,
                "Outgoing Unicast Total Size"     => status.outgoing_unicast_bytes     = SoftEtherReader::decode_bytes( val )?,
                "Outgoing Broadcast Packets"      => status.outgoing_broadcast_packets = SoftEtherReader::decode_packets( val )?,
                "Outgoing Broadcast Total Size"   => status.outgoing_broadcast_bytes   = SoftEtherReader::decode_bytes( val )?,
                "Incoming Unicast Packets"        => status.incoming_unicast_packets   = SoftEtherReader::decode_packets( val )?,
                "Incoming Unicast Total Size"     => status.incoming_unicast_bytes     = SoftEtherReader::decode_bytes( val )?,
                "Incoming Broadcast Packets"      => status.incoming_broadcast_packets = SoftEtherReader::decode_packets( val )?,
                "Incoming Broadcast Total Size"   => status.incoming_broadcast_bytes   = SoftEtherReader::decode_bytes( val )?,
                _                                 => (),
            }
        }
        Ok( status )
    }

    fn decode_packets( src: &str ) -> Result<f64, Box<Error>> {
        let ret = String::from( src ).replace( ",", "" ).replace( " パケット", "" ).replace( " packets", "" ).parse()?;
        Ok( ret )
    }

    fn decode_bytes( src: &str ) -> Result<f64, Box<Error>> {
        let ret = String::from( src ).replace( ",", "" ).replace( " バイト", "" ).replace( " bytes", "" ).parse()?;
        Ok( ret )
    }
}

#[derive(Debug)]
struct HubStatus {
    pub name                      : String,
    pub online                    : bool  ,
    pub sessions                  : f64   ,
    pub sessions_client           : f64   ,
    pub sessions_bridge           : f64   ,
    pub users                     : f64   ,
    pub groups                    : f64   ,
    pub mac_tables                : f64   ,
    pub ip_tables                 : f64   ,
    pub logins                    : f64   ,
    pub outgoing_unicast_packets  : f64   ,
    pub outgoing_unicast_bytes    : f64   ,
    pub outgoing_broadcast_packets: f64   ,
    pub outgoing_broadcast_bytes  : f64   ,
    pub incoming_unicast_packets  : f64   ,
    pub incoming_unicast_bytes    : f64   ,
    pub incoming_broadcast_packets: f64   ,
    pub incoming_broadcast_bytes  : f64   ,
}

impl HubStatus {
    pub fn new() -> HubStatus {
        HubStatus {
            name                      : String::from( "" ),
            online                    : true  ,
            sessions                  : 0.0   ,
            sessions_client           : 0.0   ,
            sessions_bridge           : 0.0   ,
            users                     : 0.0   ,
            groups                    : 0.0   ,
            mac_tables                : 0.0   ,
            ip_tables                 : 0.0   ,
            logins                    : 0.0   ,
            outgoing_unicast_packets  : 0.0   ,
            outgoing_unicast_bytes    : 0.0   ,
            outgoing_broadcast_packets: 0.0   ,
            outgoing_broadcast_bytes  : 0.0   ,
            incoming_unicast_packets  : 0.0   ,
            incoming_unicast_bytes    : 0.0   ,
            incoming_broadcast_packets: 0.0   ,
            incoming_broadcast_bytes  : 0.0   ,
        }
    }
}

